捕捉查询意图的机械领域知识检索系统
          张承巍
      机械工程及自动化
        2009010512
       May 22, 2013
             1
1 引言
1.1 研究背景
   以计算机技术为代表的新兴技术，催生了现代制造技术的长足发展，制造技术也从一开始指设计制
造的狭义概念，发展到现在从采购、生产，一直延伸到销售、售后的广义概念。对于这样产品的制造全
生命周期,就会产生海量领域内技术文档，我们称之为语料库，它包括了设计需求报告、设计说明书、设
计图纸、加工工艺规程、质量检验报告、维修报告等文档。据报道，在某航空企业，仅仅与一个发动机
相关的文档就高达40000份，其中63%是文本信息。 [1]
   面对瞬息万变的市场，企业要能及时做出反应，就必须以旧产品的技术积累为基础，加速新产品的
开发过程。统计表明，产品全生命周期的成本在产品设计阶段有90%已经被决定，产品的质量和性能也在
设计阶段被确定下来。 [2] 设计人员在产品全生命周期中的作用可见一斑。但是设计人员的知识始终是有
限的，需要在设计过程中不断查询和学习新知识，但是文献 [1] 中提到，设计人员有20-30%的时间是在查
询和交流设计信息。
   这就带来一个问题，如何组织少量的文档，并从中快速而准确搜索出设计人员所需要的信息。幸而
各种技术文档已经从纸张化发展到无纸化，我们可以用更先进的数据信息组织方式，更高效的搜索方
法，来达到这一目标。
   目前，用于领域文档的搜索一般是基于关键词的全文搜索，其原理在于通过关键词匹配进行搜索，
显然这种方法十分生硬，搜索引擎只是通过对比文字的编码信息进行搜索，却并没有理解关键词的真
实含义，很容易形成语义鸿沟。在出现一词多义和同义词情况时，往往不能检索到理想的结果。比如搜
索“梅西进球”，出现的网页都是同时包含了“梅西”和“进球 ”的页面，如图??，但是却没有“梅西
得分”的页面，但根据人的理解，“进球”与“得分”应该表示同一个意思。
                      图 1: 基于关键词搜索结果
   搜索的目的在于获取知识，自然语言是表达知识的一种形式，却不是唯一的形式。在计算机技术
中，自然语言是不容易被理解的，人们就提出了用本体来表达知识的方式，本体也成为了现代语义网的
支柱。
   本体（Ontology）最初是一个哲学概念，后被引入到计算机技术中，Neches等人最先定义了本体，
即“给出构成相关领域词汇的基本术语和关系，以及利用这些术语和关系构成的规定这些词汇外延的规
则的定义。”3本体优势在于其精确的描述，可以摆脱语言层面的干扰，而真正上升到概念层面进行描
述，为语义搜索提供基础，通过推理机，也能把隐性知识转换成显性知识。比如，“汤姆是一只猫”，
就可以推理出“汤姆是一个动物”，以此为基础，不仅可以检索到汤姆作为一只猫的特征，也可以检索
到汤姆作为一个动物的特征。这种基于本体的语义性搜索，就可以给用户提供更多的有用信息。
   对搜索性能的评估，主要有两个参数——查全率（Recall）和查准率（Precision），查全率用来衡
量搜索系统查找相关文档的能力；而查准率用来衡量搜索系统过滤非相关文档的能力。4显然，基于本体
的语义性搜索，可以规避词语可能出现的歧义，通过推理机，合理拓展搜索范围，从而有效提高搜索的
                              2
查准率和查全率。现在，也存在SPARQL等查询语言，可以实现精确的语义网搜索，但是它有一套复杂的
语法，要求终端用户具有本体等多方面的知识，并不能真正的提高搜索效率。
     针对上述问题，本项目拟以机械领域为例，建立一种基于本体的语义性搜索系统。使得用户可以像
常规方式那样输入关键词，系统首先用本体对关键词进行语义解析和扩展，再在语料库中进行搜索，给
用户提供丰富而精确的查询结果。
1.2 发展现状
     对于基于本体的语义性搜索系统，需要对本体和语义性搜索两个方面进行研究。
1.2.1 本体
     根据应用范围的不同，本体可分为领域本体、通用本体、应用本体等。领域本体指在特定类型领域
或某个学科的相关知识组成的本体。通用本体则涵盖若干个领域。应用本体包含某个特定领域的设计知
识。
     Fabian M. Suchanek [3] 等人介绍了YAGO本体，它从维基百科和语义网上获得知识，涵盖面广，信息
准确，还提供了强大的查询接口，是一种被广泛运用的通用本体。
     Ashburner [4] 等人建立了生物过程、分子功能、细胞组成三个本体，组成基因联合本体，生成了一
套用于真核生物的动态可控的词库，同时扩展了细胞中基因和蛋白质功能增加和变化的知识，还建立了
网站(http://www.geneontology.org)，提供搜索接口，是领域本体与搜索结合的，应用于实际研究的例
子。
     Maedche [5] 等人提出了一种本体学习框架，通过半自动的本体构建工具搭建典型的本体工作环境，
通过本体导入、提取、修剪、提纯、评估等步骤进行建模，同时提出了用自由文本、字典等非结构文本
进行本体构建的方法。
     Deborah L. McGuinness [6] 等人介绍了OWL语言，比较其与XML，RDF，RDF Schema(RDF-S)的差异，阐
释为什么要采用OWL语言进行本体描述，并分别介绍了OWL三种子语言：Owl Lite，OWL DL，OWL FULL的
联系与区别。为最后选择本体描述方法提供指导。
     上海交大王英林 [7] 等人提出基于本体、知识处理模块与基于实例推理方法的可重构知识管理系统框
架，实现了知识类型扩充的功能，讨论了基于工作流程的协作知识生产方法。
     中科院数学研究所金芝 [8] 等人开发了一套基于本体的需求自动获取方法，该方法以企业本体和领域
本体为线索来描述现系统，重用领域需求模型以构造应用软件需求模型，是本体的另一种运用方法。
     中国科学院文献情报中心李景 [9] 等对构建知识本体的方法体系进行了比较研究，阐述了当前常用的
7种知识本体构建方法，分别探讨它们的优缺点。
1.2.2 语义性搜索
     Sara Cohen [10] 研发了一种面向XML的语义性搜索系统，支持用简易的检索语言进行搜索，并用扩展
信息检索系统将查询结果进行排序，输出与查询相关的文档块。
     Thanh Tran [11] 等人提出一种基于本体的语义性搜索方法，其核心在于用本体将搜索关键词转换成为
查询语言，这种方法可以用于浏览声明过的知识，完成一些语义搜索，但是之后的评估表明这种方法存
在一定的局限性。
     基于上述的方法，Qi Zhou [12] 等人开发出一套“Spark”系统，将关键词翻译成正式的逻辑查询，使
得用户可以用熟悉的关键字搜索实现语义搜索的功能。
     Li Ding [13] 等人开发了一套基于爬虫索引的语义网搜索系统“Swoogle”，其工作方法是将找到文档
的元数据抽取出来，计算出文章之间的关系，再以URI作为索引关键字来查找相关文章。
     METU的Soner Kara [14] 等人运用语义性索引，提出了一种基于本体的检索系统。先用爬虫程序获得数
据，将本体实例化，通过信息抽取和推理得到完全的实例关系OWL（Ontology Web Language），再转换
成索引进行搜索。并把它应用于足球领域，拥有较好的搜索性能。
     Sugato Chakrabarty [15] 等人通过建立同义词表，一定程度上解决了类似缩写与全称的同义词关系，
提高了查全率，并成功运用在了通用汽车公司的维修查询系统中。
     普渡大学的Zhanjun Li [16] 等人提出了一种框架，采用本体基础和算法来处理复杂查询，通过计算相
关度，在一词多义的情况下，准确判断出用户的真实意图。
     台湾大学的Hsien-Tang Lin [17] 等人设计了一种方法，通过领域知识，把文章化分为段落，再把每个
段落作为一篇独立的文章，解决了对于较长文章有多个主题，不便于进行处理的问题。
     浙江大学的胡玥姮用PLIB本体和XML技术对制造信息进行结构化描述，建立描述网页内容混合向量空
间模型，设计了对零件资源信息的概念搜索系统。
     中国人民大学的Anjian Ren [18] 等人利用现成的YAGO本体，针对用户的具体查询，自动生成合适的分
类，克服了在搜索关键字过于笼统时，搜索结果不理想的问题。
                                         3
     上海交大的Dong Yang [19] 等人，用基于本体的方法，开发出一套可以自动进行产品配置系统，以同
时满足客户需求和技术指标。
     浙江大学郭剑锋 [20] 等人建立了零件库本体，并实现了关键字扩展搜索。
     综上所述，现在基于本体的语义性搜索是研究的热点问题，国内外研究取得了一些成果，但是也存
在很多问题。首先，在需要大量设计知识的机械设计领域，并没有构建出一个较完整的本体，谷歌等通
用的搜索工具又不便于搜索出专业性较强的设计知识。其次，没有提出一种扩展性较好的方法框架，文
献 [13] 中提到了其方法具有较好的可扩展性，但是其前提是所涉及领域模板简单。本项目以较为庞大的机
械设计领域为例，开发出一套具有较高可扩展性，可移植性的基于本体的语义性搜索系统。
1.3 论文主要研究内容
     本项目拟通过本体描述机械设计知识,基于本体组织语料库,形成以本体为骨架、语料库为内容的机
械设计领域的知识库。 再利用本体的扩展和推理功能, 真正从语义层面理解用户的查询要求,通过一定
的搜索算法,在知识库中搜索出相关度较高的条目作为搜索结果。
     系统开发流程：首先,构建机械设计本体作为搜索系统的核心;其次,探究如何运用本体进行知识的推
理和语义的扩展,建立扩展性语义搜索算法;然后用爬虫程序获得模拟语料库,用本体重新组织语料库,从
而获得搜索的知识库;最后,将以上几个部分结合在一起,增加用户接口,完成搜索系统的搭建。
     本文以机械产品设计为背景，设计并开发了一种机械设计知识搜索引擎系统，并针对其中的若干关
键技术进行了深入研究。具体研究工作包括：
  1. 研究知识的表达和存储方式，研究本体构建技术，扩展和推理功能。以本体描述机械设计知识，从
      而实现自然语言和搜索系统的联系。研究本体建模理论，构建机械设计的基础本体，确定本体建模
      工具。正确使用Class， Individual， Object Property， Data Property建模类型，建立恰当的
      继承关系，Characteristic特性（即函数关系，反函数关系，对称关系，反对称关系，传递性等）
      及Object的逆特性，从而为后面的推理过程提供基础。采用基于Web本体描述语言（OWL）的形式化
      描述语言，方便之后步骤中对于本体的调用。研究Class层与Individual层的关系，为后续本体的
      扩展提供支持，为在搜索时进行合理的关键词扩展提供方便。
  2. 研究可以实现语义扩展功能的、具有设置参数接口的搜索算法，并提出一种评分和排序方式，使得
      排序靠前的结果更可能是用户最想要得到的结果，达到捕捉用号意图的目的。
  3. 研究Web应用系统的相关常用技术，包括搭建服务器，数据库技术，前端设计等。为保证搜索系
      统的跨平台通用性和可扩展性，将其定位为Web应用，采用B/S(Browser/Server)架构，而不是C/
      S(Client/Server)架构，这样就不用在客户端安装专用搜索软件，只需在浏览器中，像进入普通网
      页那样，就可以实现搜索，大大提高了搜索的便捷性，这也就要求需要架设服务器，通过数据库来
      管理维护知识库，并且编写友好的用户界面，方便用户使用。
  4. 研究知识库建立的方法，通过爬虫程序，在维基百科上获得与机械相关词条网页，对其进行解析，
      去掉HTML标签，获得非结构化的文本信息，模拟语料库，以关系数据库的方式进行存储。研究关系
      数据库与本体之间建立的关系，以本体为骨架，数据库为内容，重新组织数据库，以提高搜索效
      率。
  5. 设计并开发一种基于本体的、具有语义扩展功能的搜索引擎基础架构，提供灵活的参数设置接口和
      底层数据更新接口，为知识检索提供一种高效的方式。在理论和方法研究的基础上，集成各功能模
      块，增加用户操作界面，研究各模块之间信息交流，相互调用的方式。使得各模块具有自己较为独
      立的功能，以实现之后对于其他领域应用的扩展，松散耦合地集成模块，并将此架构运用于机械领
      域，开发出捕捉查询意图的机械领域知识检索系统，并进行性能验证。
1.4 论文结构
     论文后续部分将围绕捕捉查询意图的机械领域知识检索系统的设计开发以及其中关键的技术研究展
开。具体的安排如下：
     第一部分介绍论文的研究背景和研究意义，阐释具有语义扩展性功能的、可以捕捉查询意图的搜索
系统的重要性，并对相关技术的研究现状进行了介绍。最后，给出了论文的研究内容和组织结构。
     第二部分介绍捕捉查询意图的知识检索系统的总体设计，通过介绍现有搜索引擎技术，提出功能扩
展的方法，建立系统体系结构图，从而引出系统中包含的若干关键技术，为后续章节中相关关键技术的
阐述提供系统背景。
     第三部分介绍知识的表达方式，引出本体，介绍本体的基本属性和构建方法，利用本体的推理功
能，实现隐性知识到显性知识的过渡，实现语义的扩展。介绍本体的存储方式，并介绍操作本体的Java
工具包——Jena。最后介绍了一种建立本体的软件——Protégé。
                                     4
     第四部分首先介绍扩展性语义搜索算法的其本原理及定性的排序方式，然后介绍Java工具包——
Lucene及其功能实现的方式，接下来阐述排序的定量依据，最后介绍对搜索系统性能的评价指标。
     第五部分介绍其他在系统实施阶段所涉及的技术，这些技术也是开发Web应用的基本技术，包括数据
库技术，搭建服务器,以及前端UI编写。最后介绍B/S架构的优势及其在系统中的应用。
     第六部分在前几章对体系结构和关键技术介绍的基础上，以软件工程的思路，从需求分析、概要设
计、详细设计，三个层面进行分析和阐述，介绍搜索系统是如何实现的。最后展示系统使用全貌，并进
行系统的性能测试。
2 总体设计与关键技术
     本部分简要介绍捕捉查询意图的机械领域知识检索系统的总体设计与关键技术。本文首先对普通搜
索引擎的核心和机制进行介绍，以此为基础框架，扩展出本项目的检索系统的大致框架。进行系统整体
设计，探讨知识表达的技术并确定知识表达的方法，构建系统体系结构。最后梳理其中涉及的关键技
术，包括本体的构建和扩展性主义搜索算法。
2.1 搜索引擎简介
     要了解搜索引擎，首先需要了解信息检索技术。信息检索（Information retrieval，IR）是指从
大规模电子文本（通常存储在计算机上）找出满足信息检索要求的非结构化的自然语言数据（通常是文
本）。 [21]
     信息检索技术的应用已经非常普遍，几乎所有与网络有关系的人，都会或多或少地使用该技术。目
前，Google和Bing，国内的百度，作为一种Web搜索引擎，已经让信息检索技术深入寻常百姓家，成为目
前为止最普遍和大量使用的信息检索服务的形式。与此同时，电子图书馆中检索期刊文章和会议报告，
大型企业中利用企业搜索系统来管理和查询电子邮件、备忘录、技术报告和其他业务文档，也是信息检
索就用的突出体现。
     由此，可以看出搜索引擎是信息检索的一种具体应用，而信息检索技术是搜索引擎的核心。
2.1.1 搜索引擎本质
     搜索引擎的核心是信息检索技术，检索模型提供了一种度量查询和文档之间相似度的方法。 文
献 [23] 对搜索引擎进行了数学表述，即通过一定结构维护文档集M，定义一个相关性函数SC(Similarity
Coefficient)，其满足：
                                            SC : D × Q −→ R                         (1)
     其中D代表文档集，Q代表用户的所有可能检索请求集合，R代表实数集合。当用户给定一个检索请求
q时，搜索引擎的目标是利用相关性函数sc为D中的文本打分，从而在文档集D中找到一个k元素的有序的
文档序列T：
              T = {m1 , m2 , m3 , · · · , mk }, ∀m ∈ T 且n ∈ T 满足SC(q, m) > SC(q, n)
                                                            ¯                       (2)
     即查询结果的文本序列T中的文本总是比那些序列之外的文本得分要高。
     与此同时，在文本的内部，也满足：
                                     ∀i < j, SC(q, mi ) > SC(q, mj )                (3)
     即排在前面的文档（编号较小）得分总比排在后面的文档高。
     由此，搜索系统的根本归结在了建立式1中的相关性函数，即检索模型。
2.1.2 检索模型
     常用的检索模型有如下几种：
    • 布尔模型：原始的布尔模型通过查询与文档的简单比对，判断出二者相同或不相同，相当于相似度
      只有无穷和零两种情况，没有相似度的考量，是最原始最朴素的模型，之后，通过对查询词条加进
      权重，给出了一种可以进行相关性排序的算法。 [24]
    • 向量空间模型：将查询和文档表示为词项空间中的向量，判断相似度的传统方法是计算两个向量
      的内积，计算其余弦相似度，以此反映查询与文档的相似度。 [25] 之后，通过引入不同文档集的权
      重，提出了TF-IDF（词频-文档逆向频率） [26] 来表达相似度的模型。
    • 概率模型：把相似度问题降为概率论应用的问题，通过计算文档与查询相关的概率，来表示文档和
      查询的相似度。
                                                     5
    • 语言模型：用文档中词的概率分布，为每一个文本建立一个语言模型，然后通过伯努利事件进行建
      模， 以条件概率来表达文档和查询的相似度。 [27]
     此外，较常用的检索模型还有推理网络、LSI（隐性语言检索）、神经网络方法、遗传算法、模糊集
检索等模型，此不再赘述。
2.1.3 搜索引擎基本架构
     一个常规的搜索流程如图2，通过爬虫程序，从互联网上获得文本，构成原始资料库，以此建立索
引库和有序资料库，搜索引擎的用户在文本框里输入一个简单的查询（query），它可能包含几个词项
（term），通过索引库的逆排索引（inverted index）获得相关搜索结果在有序资料库中的位置，然后
将结果显示给用户。
                       图 2: 搜索引擎基本架构
2.2 总体设计
2.2.1 知识的表达
     知识是人们在社会实践活动中所获得的认识和经验的总和。具体地说，知识是人们对客观世界的规
律性的认识。 [28]
     在漫长的人类文明中，人类积累了丰富的知识，它们被以文字、图表、声音、图像等形式记录下
来，但是对它们的高效重用，仍然是制约发展的重要因素。以机械设计为例，众所周知，该领域的经验
比知识更重要，但是经验的积累是从实践中逐步内化的，需要漫长的时间，有的经验以文字的形式记录
下来，在重用的时候却发现检索的成本太高，这就造成了经验层面的知识无法进行较直接的高效的传
承。
     随着信息技术的发展，知识工程、人工智能等新兴的领域也取得了日新月异的进步，它们研究的核
心之一就是高效地存储、获取和使用知识。机械设计知识的检索也是一种知识检索的形式，在此，有必
要就人工智能中知识的分类和表达进行简要的介绍。知识大致可以分为以下几类：
    • 事实性知识：陈述客观性的知识，比如齿轮机构可以传递力和运动。事实性知识一般采用直接表示
      的形式。
    • 过程性知识：描述做某件事的流程，比如轴的加工工序。
    • 规则性知识：亦称产生式规则（Production Rule)，规则性知识由两部分构成，一部分是前提，另
      一部分是结果，用逻辑关系"IF THEN"来描述。
    • 启发式知识：对解决问题有帮助的经验法则或技术，这种知识在描述上较为困难，有效性和效率都
      有待于研究，是人工智能的主要课题之一。
                                6
   • 实例性知识：包括已经形成的大批观察数据和案例，关于事物的知识都隐蔽在实例之中，这不是直
     接的知识，确实其他类型知识的重要来源。
   • 元知识：即所谓关于知识的知识，它告诉系统如何利用系统内部存储的知识，指导了系统运行和推
     理。
    由此可以看出，本搜索系统的功能之一，就是要得利用元知识将隐蔽在实例性知识中的其他知识挖
掘并呈现出来。
    人类的交流是基于自然语言的，要实现人机的交流，就需要将自然语言表述的知识转化成计算机可
以使用的。这就涉及到知识表示（Representation of Knowledge）问题，现在成功运用的知识表示形式
主要包括：数理逻辑，产生式规则，语义网络，框架，剧本，本体，下面就此进行简要介绍。
    数理逻辑是用逻辑符号语言进行精确的，没有歧义的描述，用数学方法进行研究；产生式规则表示
为“if A then B"，即如果A则B，以此可以实现正、反两种推理；语义网络是用网络的形式，用弧连接
概念，这样就把概念和它们的关系转换成了一张结构图；框架由框架、槽（属性）、侧面、值组成，一
个槽可包含若干侧面，一个槽对应一个值，这样就形成了对于知识的树状描述；剧本描述了事件的起
因、因果及事件间的关系，便于描述业务流程。本体定义了公共词汇集，把现实社会中某个应用领域抽
象成概念及概念间的关系，以此来实现信息共享和知识共享。
    本系统采用本体来描述知识，并以此实现语义扩展，隐性知识向显性知识转换的功能。下面就对本
体作介绍。
    本体最初是一个哲学概念，是指关于存在及其本质和规律的学说，在哲学中记作本体论（Ontol-
ogy）。后被引入到计算机技术中，用以概括概念及它们之间的关系，记作本体（ontology）。在1993
年，Gruber定义了本体——“本体是概念化（Conceptualization）的一个显示的（Explicit）规范说明
或表示。” [29] 在一些简单情况下，本体只是概念的分类层次结构，就像植物学、动物学分类，领域本
体以概念树的方式，将概念进行分类，如图3。
                           图 3: 生物分类图
    但是这样简单的树状结构是难以描绘真实情况的，比如，针对一个直齿圆柱齿轮，从分类上说，它
是齿轮的一种，所以应该是是齿轮的子结点，但是对一个装配体，在其装配树结构中，齿轮可能又是一
个变速箱的子结点。所以，作为一个描述知识的方式，概念树就太过简单了，所以在复杂情况下，本体
并不是简单的概念树，而是又加入了关系、公理、规则。
    一个完整的本体包括5类基本元素：概念、关系、函数、公理、实例。即：O ::= {C, R, F, A, I}。 [28]
    C：概念（concept），除一般意义的概念外，还拓展到任务、功能等。
    R：关系（relationship），描述概念之间的关系，比如“subclass-of”（子类），可以表示一个
概念继承了另一个概念。关系可以表述为R : C1 × C2 × · · · × Cn 即C1 、C2 、 · · · 、Cn 之间存在n元关系。
    F：函数（function），即某个元素Ca 可以由其他元素 {Ci }唯一确定，比如对于一个圆形，知道其
半径，就可确定其面积。
    A：公理（axiom），概念或关系所满足的永真式，比如一个子类继承其父类的特征。
    I：实例（instance），概念类所对应的具体实体。
    当然，关于本体，到目前为止仍没有明确的数学定义，所以对于上述元素，在实际应用中，可能还
根据需要进行设计。在后续部分将会做阐述。
    本体优势在于其精确的描述，可以摆脱语言层面的干扰，而真正上升到概念层面进行描述，为语义
搜索提供基础。通过推理机，也能把隐性知识转换成显性知识。比如，“汤姆是一只猫”，就可以推理
                                 7
出“汤姆是一个动物”，以此为基础，不仅可以检索到汤姆作为一只猫的特征，也可以检索到汤姆作为
一个动物的特征。这种基于本体的语义性搜索，就可以给用户提供更多的有用信息。
2.2.2 系统体系结构
     本文设计并开发了捕捉查询意图的机械领域知识检索系统，以此进行机械知识的快速查找。作为搜
索引擎的一种，本系统具有与经典搜索引擎相似的体系结构，但是由于从本档库组织、搜索方法等方面
都有其特殊性，所以同一般网页网页搜索引擎相比，本系统又有其特殊之处，下面介绍捕捉查询意图的
机械领域知识检索系统的体系结构。
     本系统体系结构如图4,系统自下而上分为资源层，应用服务层，表示层，客户端层。
                       图 4: 搜索引擎基本架构
    • 资源层：资源层为检索系统提供了有组织的文档库，它是通过爬早程序从互联网上获得的文档，通
      过解析操作，去掉了HTML标签，转化为非结构化文本，将其组织在数据库中，作为被搜索的文本；
      提供了领域本体，本体的建立结合了人的认识规律，按照本科教学的学习培养方案，将《机械原理
      教程》《机械设计教程》进行一定的简化和概括，再按照一定的本体构建规则，以本体形式录入，
      作为扩展性语义搜索算法的基础；提供了本体的实例层，为实例搜索提供数据源，同时，由于本体
      的推理功能是在实例层进行的，所以为实现推理功能，而不是单纯的扩展功能，需要将一些重要概
      念进行实例化，从而更好地利用了本体的另一强大功能。
    • 应用服务层：应用服务层主要包括两个部分：Java工具包层，提供Jena、Lucene、Hibernate等工
      具包，Jena实现了本体的读取操作、Lucene实现文档库索引与搜索功能、Hibernate实现操作数据
      库的功能。这些工具包强大而灵活，为系统开发提供了极大的便利，缩短了开发周期。该层也是连
      接应用服务层与资源层的枢纽层。
      功能集层：这是检索系统的核心部分，提供扩展性语义搜索功能，索引器功能和数据库维护器功
      能。索引器可以对特定目录的文档创建索引，数据库维护器可以把这些文档加入到搜索数据库中，
      从而实现了知识库维护功能，将本体、知识库、扩展性语义搜索算法松散耦合地集成在一起，同时
      提供灵活丰富的接口，保证与表示层的正常通讯，同时为今后功能扩展提供支持。
    • 表示层：在表示层内采用开源泉的Tomcat容器架设服务器，采用B/S架构，在服务器端完成大部分
      业务逻辑，减轻客户端负载。采用Javascript和ExtJS库编写用户界面，可以相对容易地实现美观
      友好的用户界面，使用户便于使用系统提供的功能集。这样，就保证了系统的跨平台性。
    • 客户端层：客户端层为用户终端，由于系统采用了B/S架构，用户无需安装客户端软件，只需像登
      录普通网页那样，登录检索系统网页，就可以使用系统各项功能。系统逻辑主要由部署在服务器端
                               8
     的程序完成，这样也就使对客户端层的设备配置要求低，保证了系统的跨平台性。由于对移动平台
     的兼容性，可以让设计人员在任何时候都能方便地查询所需要的设计知识，符合了“随时随地设
     计”的理念。
     系统工作功能框图如图5。
                           图 5: 系统工作功能框图
     通过抽象机械设计书籍中的概念，用Protégé建立领域本体；通过爬虫程序，从互联网上获得领域相
关的文本，将这些文本录入到数据库中，同时通过Lucene建立文本索引。搜索引擎可以通过Lucene调用
索引，通过Jena 调用领域本体，当用户有查询请求时，通过用户界面将查询传到搜索引擎中，进行搜
索，获得结果ID，从数据库中获得对应ID的文本，在用户界面中呈现出来，完成搜索流程。
2.3 关键技术概述
2.3.1 本体的构建
     根据搜索系统要求，利用本体主要完成两方面的任务：
  1. 实现语义的扩展
  2. 实现知识的推理
结合这样的要求，拟定本体构建的大致思路如下：
     首先，针对机械设计领域的知识，将概念化分为三大类(Protégé中称作Class)：object(对象)，
function(功能)，feature(特征)。对象包括机构、构件、运动副、零件等客观存在的实体；功能就表示
机构、零件等对象可以实现的功能，比如齿轮机构可以改变转速，改变转速就是一种功能；特征则描述
对象的基本特征，形状特征定义了诸如分度圆等可以描述零件尺寸的特征，物理量特征则对形特征（比
如分度圆直径）和功能（比如传动比）进行定量描述。这样，就可以建立出粗略的树状结构的领域本
体，并且可以直接采用它们的继承和被继承的关系。
     然后，在以上一步建立的树状本体基础上，添加关系(Protégé中称作对象属性（Object Prop-
erty）。与上述三类概念对应，将关系也分成三类：“具有对象”，“具有功能”，“具有特征”，这
样就可以沟通上述三大类概念。比如建立“具有功能”关系，将齿轮机构与传递功能相联系。这样一
来，就把概念树扩展成为了一个有向图G = (C, R)，从而为实现语义扩展提供基础。
     接下来，建立上一步中建立的关系的函数特性。在Protégé中，这些特性（Characteristic）包括
函数关系、反函数关系、对称关系、反对称关系、传递关系等，这些关系将在后文进行介绍。通过这
些关系，实现推理功能，将潜在的关系挖掘出来，将隐性知识转换成显性知识，得到一张扩展有向
图G‘ = (C, R’)，它能使语义获得更丰富的扩展。
     最后，根据需要，再建立相应的实例，完成本体的构建。
                                  9
2.3.2 扩展性语义搜索算法
     通过本体的构建，可以获得一张表述概念及概念关系（包括显性的和隐性的）图G‘ = (C, R’)，
下面就要建立一种算法来实现语义的扩展搜索算法。在目前目前暂时不考虑搜索的时间复杂度的情况
下，搜索算法可以归结为之前所提到的式1中的相关性函数，即一种对搜索结果的打分机制。按照这样的
想法，拟定搜索算法流程，如图6。
                             图 6: 搜索算法流程
     首先，用户输入一个关键词t，系统读取图G'，确定了t在G'中的位置，根据搜索半径r，确定与关
键词t相关的概念{c},然后获得t与{c}中各关键词ci 的关系Rti ，在一个可修改的权值配置文件中，定义
了不同类型的关系R对应的权值，这样就可以建立一张关于词-权的映射表，再通过这张表，生成能够被
Lucene读取的搜索词条，最后进行搜索。
     Lucene中的加权搜索评分机制将会在后文进行介绍。
     这样就实现了具有权值配置功能的，扩展性语义搜索算法。
3 本体的构建
     本部分具体介绍本体构建的实施步骤，具体介绍了采用Protégé软件进行本体概念树建立、概念关系
的添加、关系特征的描述的方法，通过阐述关系特性的性质，说明本体实现推理的机理。接下来，介绍
本体的存储方式以及用Jena包对本体进行读写操作的方法。最后对本体建模采用的软件Protégé进行简单
介绍。
3.1 准备知识
     本体是一种形式，它可以用不同的语言来表述，不同的语言提供了不同的功能。OWL（Ontology Web
Language）是由W3C组织（World Wide Web）提出的一种描述本体的语言。在OWL中，有三种元素：类
（Class），属性（Property），个体（Individual）。它可以近似地与之前提到的概念、关系、实例相
对应。
3.2 建立本体的雏形
     在Protégé中建立本体，首先面对的类的问题，类并不是孤立的概念，而是已经设定了子类（Sub-
Class）和超类（SuperClass）等相关的概念并且设定了子类会继承其超类的属性。比如前文所提到的，
汤姆是“猫”的一个个体，“猫”具有一个超类是“动物”，当描述了动物“具有眼睛”这样的属性，
猫也会继承“具有眼睛”这样的属性。
     在建模的初始阶段，会遇到这样的问题。常见的从属关系有两种，一种是“is-a”，如图7；一种
是“part-of“，如图8。
     “is-a“是本体组织的一种核心关系，用它可以描述出概念的三种关系：包含、相交、独立。
     若两个概念存在包含关系，则它们在“is-a”层次中处于上下层的父子关系；若两个概念存在相交
关系，则它们在“is-a”层次中处于同一层的兄弟关系，即具有相同的父亲；若两个概念是独立的，则
它们在“is-a“层次中没有直接的联系。
                                   10
           图 7: “is-a”关系                     图 8: “part-of”关系
   容易混淆的一种情况是“part-of”，“part-of”表示了一种部分与整体的关系，就像机械领域
中的产品结构树，管理领域的部分划分，都是一种树状的结构，但在建模时，如果误把这种关系当作
类的结构，就会造成继承特性无法正常使用。比如，在图7所示的关系中，当给“动物”赋予有生命这
一属性的时候，其子类“猫”、“狗”、“人”都继承了这一属性，易于理解，无论是人、狗、还是
猫，都是具有生命的。但是如果误用了“part-of”结构，会发生什么事情呢？举个例子。在图8所示的
关系中，如果给“人”赋予了“能说话”这样的属性，那么它的子类也会继承这样的属性，也就意味
着“手”“能说话”，“脚”“能说话”，这显然是荒谬的。这也就解释了，在Protégé的类中，有一个
根类“Thing”，因为无论是对象、或是特征，它们都应该是一种事物（Thing）。
   这就要求在本体建立过程中，必须反复验证是否采用了“is-a”的方式进行类的组织，验证的方法
就是在添加一个子类的时候，跟其父类作这样的一个判定“子类 是 父类 的一种吗？”比如，对于“齿
轮”类，建立其子类“直齿圆柱齿轮”，容易判断，直齿圆柱齿轮是齿轮的一种，所以这个父子关系是
正确的。但是对于“变速箱”类，“直齿圆柱齿轮”就不能是其子类，因为我们容易判断“直齿圆柱齿
轮是变速箱的一种”这种表述是错误的。通过这样的方法，就能够建立起能够合理利用OWL中父子继承关
系的本体。
   用这样的方法，建立起了本体的雏形，粗略的树状结构的领域本体。对于一张本体图G = (C, R)，
现在就完成了C（概念）部分的建模。下面进行关系（R）层次的建模。
3.3 建立关系
   在上一步中，建立了树状结构的领域本体，完成了本体的概念部分建模。通过树的结构，也进行了
概念间父子继承关系建模，下面将完善关系层次的建模。
   在Protégé中，与OWL中的Property（属性）元素相对应的有三种：对象属性(Object Property)，数
据属性（Data Property），注释属性（Annotation Property）。在一个“主-谓-宾”三元描述中，属
性都充当了谓语的功能。
   对象属性：根据Protégé提供的官方讲义，对象属性是用于描述个体关系的，但是在建模过程中，个
体都不是孤立的，它们都依托于一些特定的类，所以对象属性可以借用来描述概念与概念之间的关系，
此处的概念是指用户自己建立的类，也就是说，对象属性所连接的主语和宾语都是用户建立的概念。
   数据属性：根据Protégé提供的官方讲义，数据属性联系了个体和数据值（Data Value）之间的关
系，与上一种情况相同，建模过程中，也可以用以联系概念与数据值之间的关系。数据值的类型涵盖了
XML（可扩展建模语言）概要数据类型和RDF（资源描述框架）文字，也就是整型、实型等数据类型。事
实上，可以把数据属性理解成一种特殊的对象属性，把数据值理解成一种特殊的类。
   注释属性用于添加信息（元知识），它的主语可以是类、个体，也可以是对象属性或数据属性；宾
语则是一些系统定义的元知识类型，比如label（标签），versionInfo（版本信息）等，当然用户也可
以自行添加。在机械领域本体建模过程中，就添加了“inChinese”类型的元知识，由于概念层均是用英
文书写，用这样一个注释属性可以建立中英文的对照，为今后系统兼容中文提供支持。与数据属性相类
似，可以把注释属性及元知识与对象属性和类建立对应关系，这样就从本体的概念上统一了三种属性。
   由于概念分类上，领域的概念被分成了对象、特征、功能三大类，那么，建立关系的重要任务之
一就是要彼此沟通这三类概念、沟通同一类概念的跨级关系，所以与它们相对应地，建立了三种对象
属性，“具有功能”，“具有特征”，“具有对象”。这三种关系的主语都是对象类，由于后文将会提
到的对称性，就能实现“对象-对象”，“对象-功能”，“功能-对象”，“对象-特征”，“特征－对
象”几种关系。接下来，再根据要求，将几类关系进行一定的细分，就能完成本体图中R（关系）部分的
                                 11
建模。
     然后，进行概念层和关系层进行耦合。一种简单的情况是“齿轮机构-具有功能-传递运动”，通过
这种简单的联系，可以完成大部分概念-关系的建模。但是，在一些细节处理上，出现了两种或两种以上
的建模方式，就需要比较哪一种更好，或者说，哪一种能更好地之后的搜索功能提供基础。举一个关于
齿轮参数的例子。
     在建立关于齿轮参数模型的时候，可能有如下几种方式：
                      {
                               具有值
        具有参数            齿数z − − 数值
                               − −→
1) 齿轮 − − −→ 齿轮参数
        −−                     具有值
                        模数m − − 数值
                               − −→
    其中，齿轮、齿轮参数、齿数z、模数m为类；具有参数为对象属性；具有值为数据属性。
       {
           具有齿轮参数中的齿数z
          − − − − − − −→ 数值
           −−−−−−
2) 齿轮     具有齿轮参数中的模数m
         −− − − − − −
          − − − − − − −→ 数值
    其中，齿轮为类；齿轮参数中的齿轮z、具有齿轮参数中的模数m为数据属性。
     上面两种方法，都可以建立起齿轮、齿数、模数、具体数值之间的具体关系，后一种方法形式上看
起来简洁，但是“具有齿轮参数中的齿数z”意味着需要建立大量的类似的数据属性，且这种属性不利于
之后的搜索工作，它并没有提取出“齿数”这么关键的概念。分析将被搜索的文本，一个概念应该是比
一个数字更为重要，所以采用了第一种方法。
3.4 关系特性
     关系特性拓展了关系的含义，为本体推理提供基础。下面就对几种关系特性进行介绍。
3.4.1 函数属性（Functional Properties）
     如图一个关系具有函数属性，就意味着通过这种属性与某个个体相联系的个体最多只可能有一个。
举个例子，如图9，如果李华具有生父李四，同时李华具有生父老李，将“具有生父”赋予函数属性，就
可以推断出，李四和老李是同一个个体。用这样的方法，可以把挖掘出本体中的更多同义实体。
                                  图 9: 函数属性例子
3.4.2 反函数属性（Inverse Functional Properties）
     所谓反函数属性，是指其反属性是函数的。举例说明，如图10，如果有这样两条陈述：李四是李华
的生父，老李是李华的生父，“是其生父”具有反函数属性，那么就可以推断出，李四和老李是同一个
人。这样同样可以推断出同义个体。
     看起来，函数关系与反函数关系很相似，为了更准确地利用，必须加以严格的区别。对于函数关系
而言，是通过主语和谓语判断出不同的宾语指的是同一个体；而对于反函数关系而言，则是通过谓语和
宾语判断出不同的主语指的是同一个体。
3.4.3 传递性（Transitive Properties）
     故名思义，所谓传递性是指，如果个体A和个体B之间存在某种关系，B和C之间也存在这种关系，那
么能推理出A和C之间也存在这种关系。举个例子，如图11。现在有两条陈述，李华有祖先老李，老李有
祖先李爷爷，有祖先被定义了传递性属性，据此，就可以推理出李华具有祖先李爷爷。在前文的概念树
建模阶段，类与类的继承关系（包括子类和超类）就利用了传递性。通过传递性的扩展，子类就被推广
成了后代类，超类就被推广成为祖先类，大大拓展了一个概念的扩展范围。
                                         12
                              图 10: 反函数属性例子
                              图 11: 传递性属性例子
3.4.4 对称性（Symmetric Properties）
     如果一个关系具有对称性，也就意味着个体A到个体B具有这种关系，那么个体B到个体A也具有这种
关系。如图12，如果李华有兄弟李阳，那么根据有兄弟的对称性属性，就可以推断出李阳有兄弟李华。
通过对称性，可以将单向的关系扩展成为双向的，在关系建模阶段就得到了简化。
                              图 12: 对称性属性例子
3.4.5 其他属性
     反对称性（Asymmetric Properties）与对称性相反，反对称性是指，如果个体A到个体B存在关系
P，那么个体B到个体A就不能具有关系P。比如，如果有一个陈述，李四有孩子李华，有孩子具有反对称
属性，那么就不能存在“李华有孩子李四”这样的陈述。这种属性设置是为了检验本体的逻辑正确性，
在本系统中暂时不用。
     自反性（Reflexive Properties）指一个关系的主语宾语是同一个体；反自反性（Irreflexive
Properties）指一个关系的主语宾语不能是同一个体。这两种关系在系统中都没有运用，就不再赘述。
     以上介绍了本体关系所具有的几种常用的属性，它们将会作为本体推理的基础。
                                     13
3.5 本体推理
     以OWL语言描述本体的一个重要好处就是可以采用推理机（Reansoner）,通过推理机，可以完成三方
面的功能。第一，拓展类的层次结构关系，把子类推广到后代类，把超类推广到祖先类，这样一来，可
以很容易的回溯出一个概念在分类学上的线索，对于语言扩展而言，这是相当重要的，比如在检索直齿
圆柱齿轮的特性的同时，系统会找到其超类——齿轮，然后找到齿轮的特性，同样，齿轮作为构件的子
类，构件的性质也能被找出来，这是一个从具体的特性到抽象的共性的拔高过程，以此获取更为丰富的
信息，需要注意的是，此处的推理是在类的层次进行的；第二，检验本体的一致性，也就是检验了本体
各种关系的逻辑会不会出现矛盾，以此来判断本体的合理性，通过分析出现矛盾的情况，能够不断完善
本体，提高本体的鲁棒性；第三，通过推理机，判断某个个体是否为某个类的个体，举个例子，定义了
一个叫减速箱的类，它具有一些充要的约束条件，如具有箱体，具有数量大于2的齿轮，在检索箱体和齿
轮的时候，系统就可以推理出它是一个减速箱，从而列举出减速箱的相关信息。
     Protégé提供了FaCT++等推理机，可以在建模阶段发挥检验的作用，一方面检验本体的逻辑一致性，
另一方面检验推理出的关系是否如我们所预期。但是这种Protégé推理出来的信息并不会保存在OWL文件
中，所以在之后系统可用的本体的推理功能是通过Jena实现的。Jena将会在后文进行介绍。
3.6 本体的读取
3.6.1 本体的描述方式
     前文提到了用OWL来描述本体，但是对于这样一种本体描述语言，仍有不同的变体，来实现对本体不
同层次的描述。下面就进行简要介绍：
    • RDFS（Resource Description Framework Schema,资源描述框架）:也可写作RDF(S)，RDF-S，RDF/
      S或RDF Schema。它用XML（eXtensive Markup Language，可扩展标记语言）来描述类和属性的集
      合，可以描述本体的的基本元素。
      对于图3所示，这个本体就具有五个类，并且动物是生物的子类等等。在这种关系下，就可以说每
      个动物都是生物。所以这种类的层次关系可以理解成数学上的子集，即：{动物} ⊂ {生物}。
      用RDF形式来描述这种关系,可以表示为：
               < owl:Class rdf:about = "生物" / > </ rdf:RDF >
               < owl:Class rdf:about = "动物" >
                        < rdfs:subClassOf rdf:resource = "生物" / >
               </ owl:Class >
      第一部分建立了一种名为“生物”的类，第二部分建立了一种为“动物”的类，并且定义了它
      是“生物”类的子类。
    • OWL：OWL是RDFS的一种扩展，RDF能完成的它都能完成，同时它又多了一些扩展功能。比如对立关
      系，可以通过把两个类设置成对立关系（Disjointed），这样就保证了，不能有一个个体同时是两
      个类的实体。再比如，通过OWL可以设置上文所述的传递性、对称性等关系特性，这就大大的拓展
      了本体的表达的推理的基础，而RDFS只能建立类的层次结构。
      OWL语言具有三种子语言：OWL Lite，OWL DL和OWL Full。OWL DL和OWL Lite让层次关系更容易被
      追溯；OWL DL可以使用描述逻辑推理机（Description Logic Reasoner），使其具有更强大的查询
      功能；OWL Lite则更利于使用一些简单的推理算法。
     总体来说，本体有着不同的描述语言，从最强大的OWL Full到最精简的RDFS，建立时要根据需要进
行合理选择。
3.6.2 Jena的应用
     上文提到，采用Protégé进行了本体建模，建立了以OWL语言描述的本体。下面需要对本体进行读取
和推理等操作，Jena是Apache软件基金会资助的项目，它是一种Java框架的语义网构建应用，它提供了
方便易用的读取、加工、编写RDF数据的API以及操控RDFS和OWL本体的API。系统采用Jena工具包，实现
了本体与搜索引擎的交互，下面对一些关键的API进行简要介绍。
     本体导入： 通过ModelFactory类可以以如下代码建立本体模型：
OntModel m = ModelFactory . createOntologyModel ();
                                             14
     在无参数的情况下，可以获得一个以OWL Full语言描述的、常驻内存的、具以推理子类、超类功能
的推理机的模型。当然，在某些情况下，这种设置都太强了；而在某些情况下，这样的功能又显得局
促。在Jena中，可以用OntModelSpec对象来设置createOntologyModel方法的参数，来对建立的模型进行
配置。根据系统的实际需要，采用OWL_DL_MEM_RDFS_INF 参数进行模型建立与配置，这样就可以获得以
OWL DL语言描述的、常驻内存的、具有RDF层衍生规则的规则推理机的本体模型。
     对于每一个本体模型，还需要有一个对应的文档管理器来协助完成操作、加工的工作，OntDocu-
mentManager就起到了这种沟通本体文件与本体模型的功能。通过OntDocumentManager类的addAltEntry
方法，可以建立系统公共本体文URI和本地本体文档URI的映射，再使用OntModel类的read方法，就可以
按设定的格式进行本体读取。
OntDocumentManager dm = model . getDocumentManager ();
dm . addAltEntry ( docURI , locationURI );
model . read ( docURI ," RDF / XML " );
     经过试验验证，只有“RDf/XML”能够与Protégé建立的以“RDf/XML”格式存储的本体进行无缝的衔
接。以上完成了对本体的读操作，通过设置推理机，很容易地获得了扩展之后的本体。下面就要根据搜
索的需求，先找到一个关键词在本体中的位置，进而枚举已经定义的关系，找到与之相关的概念。如果
把关键词当作根结点，把各种关系当作第二级结点，把相关的概念当作第三级结点，那么这就构成了一
棵深度为3的树，我们要做的就是对这棵树进行深度优先的遍历，列举出所有“主-谓-宾”三元组关系
（Triple）。
     这种列举操作类似对于数据库的查询操作，在数据库有查询语言SQL，在本体中也存在相类似的查询
语言——SPARQL。
     首先要对一些概念进行解释。之前反复提到了将本体看成一张图G = (C, R)，RDF图就是表示这种图
的一种表示方式。根据W3C组织的定义 [30] ，RDF图（RDF Graph）是RDF三元组（RDF Triple）的集合。
RDF三元组包含三个部分，主语（Subject）,谓语（Predict），宾语（Object）。
                                              谓语
                                         主语 −−→ 宾语
                                              −
     需要注意区分的是，RDF是一种应用与应用间交换信息的框架，即资源描述框架；RDFS是一种基于
XML的本体描述语言；而RDF图是一种图，是三元组的集合。SPARQL的搜索对象是RDF图，它具有与SQL相
类似的语法。比如要检索齿轮（Gear）的子类，可以用下列的SPARQL。
SELECT ?x
WHERE {? x < SubClassOf > " Gear "}
但是当主语、宾语处在多层嵌套，这种语法会变得异常复杂，而且需要对RDF图的细节有较深的了解，对
于一般用户难以灵活自如地运用。但是Jena为我们提供了丰富易用的类可以胜任这个工作。
     操作本体： 在Jena中，每个概念作为一个OntClass类的对象进行存储。用Model类的getOntClass方
法，以类节点的URI为参数，这样就可以确定关键词在本体中的位置，完成主语的确定。
     下面就要枚举出所有的关系，找到所有谓语。谓语可以通过两种分类方法，分成六类，如表1
                                         表 1: 谓语的分类
                                        超类       等价类       子类
                         普通类          普通超类     普通等价类    普通子类
                       约束性类         约束性超类 约束性等价类      约束性子类
     超类、等价类、子类这种分类方法是基于概念的层次结构的，而普通类和限性性类则是基于建模不
同阶段的。对于第一种分类方法，它们的区别仅在于概念层次结构的细微差异，处理方法是类似。下面
主要讨论普通类和约束性类的区别及不同的处理方法。
     普通类谓语是在概念层次结构阶段的建模就具有的，这种谓语关系已经被蕴含在了概念树结构中，
其OWL语言表述如下
< Class rdf:about ="& Mechanical_design;4− Bar_Linkage_mechanism " >
  < rdfs:subClassOf rdf:resource =" & Mechanical_design ; Linkage_Mechanism " / >
</ Class >
     这样就定义了连杆机构和四连杆机构的继承关系，可以观察到谓语“subClassOf"的宾语是一个普通
的概念。
     另一种情况是约束性谓语，约束性谓语则相对复杂，如上文建立关系部分所提到的，我们采用了对
象属性来描述概念与概念之间的关系，但是根据官方说明，对象属性是用来描述个体关系的，所以，必
                                              15
须要采用一定的转化机制。在本体中，恰提供了这样的机制——约束（Restriction）。将上一段代码所
表示的关系进行扩展，在“四连杆机械是连杆机构”的描述之后，又加了一条“四连杆机构具有构件连
杆”，“具有构件”就是自己定义的对象属性，用OWL的表示方法如下：
< Class rdf:about ="& Mechanical_design;4− Bar_Linkage_mechanism " >
  < rdfs:subClassOf rdf:resource =" & Mechanical_design ; Linkage_Mechanism " / >
  < rdfs:subClassOf >
    < Restriction >
      < onProperty rdf:resource ="& Mechanical_design ; has_Some_Links " / >
      < onClass rdf:resource ="& Mechanical_design ; Linkage " / >
      < qualifiedCardinality rdf:datatype = " & xsd ; nonNegativeInteger " >
        3
      </ qualifiedCardinality >
    </ Restriction >
  </ rdfs:subClassOf >
</ Class >
      容易观察到，系统处理以对象属性作为概念间的关系的方法是：把真实的谓语和宾语封装成为一
个约束，这个约束再作为“subClassOf”的宾语。约束中主要包括三种元素：真实的谓语（即对象属
性），真实的宾语（即相关概念），约束类型。
      知道了这种机制，在迭代器获得关键词概念的下一个超类（或等价类，或子类）的时候，先判断出
它是普通类谓语还是约束性谓语，再分别作出对应的处理，就可以实现上述的“主-谓-宾”三元组关系
的列举，把这些关系封装成一个Triple类的对象，以备之后使用。Triple对象在后文中介绍。至此，基
本完成了与本体相关的操作：建模，读取，操作，使用。
3.7 Protégé介绍
      前文反复提到了我们所使用的本体建模软件Protégé，下面对其进行简要的介绍。
      Protégé是由斯坦佛大学与曼彻斯特大型合作开发的一款免费的开源的本体编辑器和基本知识框架。
它基于Java框架，具有极强的扩展性，通过丰富的插件，可以实现快速的原型开发与应用开发。Protégé
具有相当友好的图形界面，灵活直观地展现本体模型的体系结构与概念间错综复杂的关系。Protégé也提
供了RDF/XML,OWL/XML，Turtle等丰富的存储格式，由于Protégé的开发本身就大量地使用了Jena包，它
们的深度集成为本系统从本体建模到本体操作提供了无缝衔接提供了支持。
4 扩展性语义搜索算法
      在前文所述的工作中，我们完成了本体的构建，并且获得了读取操作本体的方法，本部分就要以此
为基础，实现扩展性语义搜索算法。首先介绍扩展性语义搜索算法的原理，然后介绍一些关于搜索的基
本方法概念，阐述系统是如何运用相关工具包实现搜索，提出搜索结果的排序依据，最后提出对搜索引
擎评价的两种指标。
4.1 原理
      前文提到，普通的基于关键词的搜索是通过简单的编码匹配，这样的方式甚至不能解决最基本的同
义词问题，就更别说实现语义的扩展了。对于一个理想的人工智能的系统来说，我们希望它能理解我们
的意思，但要表达我们的意思，还是需要以语言作为载体。这种载体不能像SPARQL查询语言那样艰深，
尽管它有强大的查询能力，但还是让大多数用户望而生畏。扩展性语义搜索算法的核心理念就在于，让
用户就像在使用普通的关键词搜索那样操作，却获得远远超越普通关键词搜索的性能。这种思想的实现
得益于以本体来描述知识的方式，通过简单的同义词关系，我们就获得了同义词搜索的功能，通过本体
中定义的其他丰富概念之间存在的关系，我们就获得了语义扩展的功能。
      实现思路是，用户输入关键词，在本体中找到该关键词并获取与之有关系的概念词，把关键词与概
念词一并作为搜索关键词进行加权搜索，获得搜索结果。如图6。
4.2 实现
4.2.1 Lucene
      Lucene同样是Apache基金会支持的项目，是一个开源的全文检索引擎工具包，是一个包含了查询引
擎、索引引擎及部分分析引擎的完整架构。Lucene 定义了一种以 8 位字节为基础的索引文件格式 ,可
                                           16
以轻松地实现跨平台下共享索引文件,同时由于众多优秀的程序员对 Lucene 做出卓越贡献,使得 Lucene
能够提供极高的搜索效率,包括苹果公司等众多商业场合,都用在使用 Lucene 进行搜索。Lucene的后台
极其复杂，运用了先进的信息检索技术，但是它提供了丰富易用的API屏蔽了后台的复杂机制，普通编程
者可以很容易地在目标系统中进行全文检索。
     Lucene很容易被误解成一个完整的搜索程序，但它其实只是一个搜索程序的两个核心模块，即索引
和搜索。这之间是什么关系呢？下面就简要介绍一个搜索程序的架构。如图13。
                                   图 13: 搜索程序架构
     可以看到，对于一个搜索程序，首先它需要从原始文本中获取内容，建立文档并分析它们，生成一
个索引文档并放在索引中，当用户有搜索请求时，他会在用户界面上中输入他的查询要求，然后系统建
立并执行一个查询（Query），在索引中获得该查询的相关信息，然后将搜索结果进行的一定的加工，再
在用户界面上呈现出来。对于Lucene，它完成的是整个架构中的深色部分，当然也是至关重要的部分。
下面就对这两个部分进行介绍。
4.2.2 索引
     搜索的任务就是要找到具有特定关键字的文件，那么怎么才能做到这一点呢？一种朴素的方法是顺
序扫描每个文件，检验文件中是否含有要这个关键字，在不记任何成本的情况下，这样做应该是可以达
到目的的。但是试想，如果搜索的对象是具有庞大数据量的数据集，或是庞大的单个文件，这种搜索方
法的效率势必是极低的。所以在进行搜索操作之前，需要把文档转换成一种能够快速搜索的格式，这种
转换过程就是所谓索引操作（indexing），其输出结果就是索引（index）。下面以倒排索引为例，解释
为什么通过索引可以提高搜索效率。
     倒排索引（Inverted Index），亦称反向索引、置入档案或反向档案，是众多索引方式中较为常用
的一种，它建立了一个词在单个或多个文档的映射，这样就可以根据词快速确定存在该词的文档列表。
比如对于以下三个文本：
     T0 = "W hat is lucene?"
     T1 = "Lucene is f or search."
     T2 = "W hat is search?"
     经过索引操作之后，就可以获得如下索引：
           " what ":    {1 ,3}
           " is ":      {1 ,2 ,3}
           " lucene ":  {1 ,2}
           " for ":     {2}
           " search ":  {2 ,3}
                                          17
    通过这样的机制，就建立了简单的索引文件。当然，根据需要，还可以把词在文档中的位置信息存
储在索引中。实际的索引比这个要复杂很多，但索引的技术细节并不我们的研究对象，此不赘述。
    下面介绍系统是如何使用Lucene建立索引，从而得到功能集中的索引器的。 在Lucene中，要执行一
个简单的索引操作需要用到以下几个类：
   • IndexWriter（写索引）
   • Directory（目录）
   • Analyzer（分析器）
   • Document（文档）
   • Field（域）
    IndexWriter是索引操作的核心类，它负责完成新建或打开索引，并且执行添加、删除及更新等操
作；Directory类则为IndexWriter存储的索引开辟空间，同时通过FSDictory.open方法，可以建立待索
引文件在文件系统中的目录与索引文件之间的对应关系；在上述的简单的索引的例子中，是人工的采用
了以空格来区分单词的方法，但在实际使用中，这种方法可能是不完备的，这就需要有一种机制，来对
文本进行解析处理，Analyzer类就是完成这件事情的，它将文本进行合理的划分，提取词汇单元，筛选
掉无用信息；文档是域的集合，Document类就实现了文档的功能；域则保存了不同种类的文本信息，比
如对于一个音乐文件，其文件名、作者、专辑名等元数据都会被存在不同的Field类中，进而被包成一个
Document类。通过这些一系列的步骤，就可以完成索引操作。实现索引操作关键代码如下：
//声名一个写索引器
IndexWriter writer = n u l l ;
//打开实际文件系统中的文件目录
Directory dir = FSDirectory . open (new File ( indexPath ));
//配置写索引器，设置索引存储空间、分析器、创建或重写及最大文件数
writer = new IndexWriter ( dir ,
                          new StandardAnalyzer ( Version . LUCENE_30 ) ,
                          true ,
                          IndexWriter . MaxFieldLength . UNLIMITED );
//声明一个类Document
Document doc = new Document ();
//建立内容（）域，配置域名、待加工内容、域存储选项及域的项向量选项CONTENTS
Field contents = new Field ( CONTENTS ,
                                   stuff . getContents () ,
                                   Field . Store . YES ,
                                   Field . Index . NOT_ANALYZED );
//以类似的方法建立文件名域文件,,域ID
//将之前建立的各域写进文档
doc . add ( contents );
    在实际建立索引过程中，每个域并不是被等同创建的。比如，如果要搜索关键词“齿轮”，其他条
件都相同的情况下，一个文件的文件名包含一次“齿轮”，另一个文件的文本内容包含一次“齿轮”，
显然前者更有可能是用户要找的文本，这就要求对不同的域采用恰当的权值进行加权操作。加权操作可
以在索引期间完成，也可以在搜索期间完成。由于后者虽然动态性较加，可以在搜索期间进行灵活的权
值确定，但这会消耗掉一定的CPU效率。所以，系统选择在索引期间进行加权，在一些特殊情况，也可
以在搜索期间把索引期间所加的权值补偿回来，这样既保证了效率，又提供了足够的灵活性。在Lucene
中，可以通过setBoost方法对文档和域进行加权操作。在此，将文件名域（filename）权值设置得略高
于内容域（contents）的权值，以突出文件名在搜索中的重要性。在一定的评价指标下，可以通过改变
权值配置，进行搜索的优化。 为了方便信息的传递，通过Lucene获得的搜索结果将会是一个文件ID号，
通过这个ID号，可以在数据库中找到对应的文档，还可以获得其他未在索引中建立，但是存储在数据库
中的信息。
                                         18
4.2.3 搜索
     建立了索引，提供了一种快速检索的机制，但是索引终究是处于后台的，要让其强大的功能得以表
现，还需要有搜索作为一个窗口。下面就要针对索引，建立相应的搜索程序，简要介绍搜索会用到的几
个基础类。
    • IndexSearcher（索引搜索）
    • Query（查询）
    • QueryParser(查询解析器)
    • TopDocs（顶部文档）
    • ScoreDoc（评分文档）
     IndexSearcher类是搜索的门户，由它完成通过索引进行的搜索操作。在实际运用中，它与其他相关
类的关系如图14。
                          图 14: IndexSeacher类与相关类的关系
     在初始化阶段，建立Directory对象用以开辟读取索引文件Index文件的空间，用一个IndexReader
类对象来读取索引文件，IndexReader需要较大的系统开销，所以在搜索过程中，最好只建立一个
IndexReader实例。下面就是搜索阶段，当IndexSearcher对象接收了一个Query类的对象，它就会用
search方法调用通过相关类调用索引文件，获得搜索结果，进行评分等工作，最后输出一个TopDocs类的
对象作为搜索结果。
     Query是一种查询请求的封装，IndexSearcher类接收Query对象作为查询的参数。针对不同的搜索
要求，Query有不同的子类来实现相应的功能，如TermQuery、 NumericRangeQuery、 TermRangeQuery、
PhraseQuery、 PrefixQuery、 FuzzyQuery、 WildcardQuery、 BooleanQuery以及MatchAllDocsQuery
等，它们可以完成通过项搜索、通过指定数字范围搜索、通过指定项范围搜索等功能、短语搜索、前缀
搜索、模糊搜索、通配符搜索、布尔搜索以及匹配所有文档搜索。这些子类可以被直接实例化，可以通
过QueryParser相应的子类来实例化，我们采用后一种方法。
     QueryParser类能把用户输入的查询表达式进行解析，把查询拆分成若干个项（term）（项是最小的
索引片段，它包含了一个域名和一个文本值），进而封装成一个Query类的对象。
     举个较为复杂的查询表达式的例子：“Camˆ4 (Link)ˆ1 (Vedge AND Cam)ˆ1 (Disc AND Cam)ˆ1
(Cylindrical AND Cam)ˆ1”，所谓解析，就是要把这种表达式转换成若干个项，再封装成对应的Query
实例。流程及类的关系如图15。
     当QueryParser接收到一个查询表达式（这个表达式可能是由用户输入，也可能是由系统生成），它
就会利用分析器（Analyzer）进行分词操作把查询语句分割成多个项，进行大小写转换等处理，再封装
成一个Query类的对象，传送给IndexSearcher类。
                                         19
                           图 15: QueryParser工作流程及与相关类关系
                                    表 2: 查询表达式范例
                  查询表达式                             匹配文档
                     Gear                    默认域包含Gear项的文档
                Gear Mechanism    默认域包含Gear和Mechanism项中一个或两个的文档
              Gear OR Mechanism   默认域包含Gear和Mechanism项中一个或两个的文档
               +Gear +Mechanism       默认域同时包含Gear和Mechanism项的文档
              Gear AND Mechanism      默认域同时包含Gear和Mechanism项的文档
     事实上，一个详细的查询表达式，能够更精确地描述查询意图。表2就列举了一些查询表达式的语法
结构。
     通过这些逻辑表达式可以更精确地限制搜索的范围。
     如前文所提到的，针对不同的搜索要求，Lucene提供了不同的查询子类，这些子类可以由不同的解
析器来进行实例化。在我们的搜索算法中，一个很重要的功能是加权，Lucene提供了相对应的功能。在
一个项后面加一个“ˆ”符号再跟一个浮点数，就会对该项查询处理进加权因子的设置 。比如，查询表
达式为“Camˆ4 (Link)ˆ1”，那么Cam的TermQuery的加权系数设为4，而将Link的TermQuery设置为1。加
权系数如何影响结果的排序将会在后文中有阐述。
     之前在索引的部分提到，在索引操作的过程中，建立了文件名域和内容域两个域，用户会更倾向于
同时对两个域进行搜索，而不是只针对其中一个。要实现这样的多域搜索功能，可以用建立全包含域的
索引的方法，也就是将把所有域的内容全拼接在一块儿，形成一个包含所有内容的域，再对这个域进行
索引，这种方法虽然在搜索效率上不错，但是显然，字符串的简单连接使得它不能进行域的加权操作。
这里系统采用了用MultiFieldQueryParser的方法。
     MultiFieldQueryParser是QueryParser的子类，它能在后台把一个QueryParser实例化，分别针对每
个域解析查询表达式，再用BooleanQuery将它们连接在一块儿。
//多域查询解析器
QueryParser multiFieldParser = new MultiFieldQueryParser ( Version . LUCENE_30 ,
                    new String [] {" filename " , " contents " } ,
                    new StandardAnalyzer ( Version . LUCENE_30 ));
     这样，就可以同时针对文件名域和内容域进行搜索，并且能够利用之前对它们进行的域的加权操
作。
     TopDocs类是一个简单的指针窗口，其对象保存了IndexSearcher获得的得分较高的搜索结果。它提
供了两个属性，totalHits用以表示匹配搜索条件的文档数量，scoreDocs是一个scoreDoc类的数组，通
过遍历scoreDocs属性，可以逐个获得搜索结果；TopDocs还提供了getMaxScore方法，用来返回最大评
分。尽管评分对于普通用户是隐性的，但是在系统调试阶段，这样的评分会作为评估系统搜索性能的重
要依据。
     ScoreDoc类则提供了对搜索结果访问的丰富接口 。
     采用这些类，就可以实现一个搜索，它即保证了基本的搜索功能，也能完成我们所设计的搜索算
法。
4.2.4 排序依据
     如式1所描述的，搜索归根结底是一种文档与评分的映射，之前反复提到了搜索结果排序，对域或项
进行加权操作等，那么文档是如何评分的，对域或项的加权操作又是如何影响评分的呢？Lucene提供了
一套完整成熟优秀的评分机制，其核心是相似度评分公式，计算方式是查询语句（q）的各项（t）与文
                                            20
档（d）的匹配程度，它深刻地描述了查询语句与对应匹配文档的相似度：
                  ∑
          SC =          (tf (t in d) × idf (t)2 × boost(t.f ield in d) × lengthN orm(t.f ield in d))
                 t in d                                                                              (4)
                         × coord(q, d) × queryN orm(q)
    下面就逐个来解释各个评分因子：
   • tf (t in d)：tf（term frequency）项频率因子。
                                                                 nt
                                               tf (t in d)＝ ∑
                                                                    in d
                                                                                                     (5)
                                                                i∈d ni in d
     ni in d 指一个项（i）在文档（d）中的出现次数 。 项频率因子描述了在某个文档（d）中出现查
     询项（t）的频率，它是对词数的归一化，以避免它偏向较长的文件。因为在较长的文件中，无论
     它重要与否，某个项可能出现的次数都有增多的趋势。
   • idf (t):idf（inversed document frequency）逆向文件频率因子。
                                                                  |D|
                                              idf (t)＝log                                            (6)
                                                          1 + |{j : t ∈ dj }|
     |D|表示文档总数，|{j : t ∈ dj }|表示包含了项（t）的文档数。分母加了1是为了避免出现项（t）
     未在任何文档中出现而造成分母为零的情况。
     逆向文件频率因子可以评价项的“唯一”性，定性地说，在包含项（t）的文档（d）越少，该因子
     越大，因此它具有很高的类别区分能力。
   • boost(t.f ield in d):域或文档的权值，如前文介绍，这个权值可以是在索引期间建立的，比如本系
     统的域加权部分；也可以是在搜索过程中建立的，比如本系统的项加权部分。
   • lengthN orm(t.f ield in d):域的归一化值（Normalization）,它表示了域中所包含项的数量。域
     的归一化值在索引操作期间建立，然后保存在norm索引中。对于域的归一化值，越短的域，词汇单
     元越少的域将会获得越大的加权。
   • coord(q, d):协调因子（Coordination factor），这是基于文档中所包含的查询的项数来确定的。
     协调因子对包含更多搜索项的文档进行类似AND的加权。
   • queryN orm(q):查询的归一化值，即查询语句（q）中每个查询项（t）权重的平方和。
    由此可见，在一串其貌不扬的具有一定顺序的搜索结果背后，隐含着复杂的统计公式。为了给编程
者提供定量分析依据，Lucene提供了Explanation类。IndexSearcher类的explain()方法通过一个Query
对象和文档的ID作为参数，可以获得一个Explanation类的对象，它包含了所有关于评分计算中各因子的
信息。在系统后台，可以以结果评分为依据，对权值设置进行调整，进而优化搜索系统。
4.3 评估指标
    建立好了搜索系统，就要对系统进行相关性和搜索质量进行评估。对于一个搜索系统来说，如果用
户没有得到他想要的结果，那么将算法描述得再怎么巧妙也是无济于事的。一个用户要求搜索系统做到
什么呢？首先，程序返回相关的文档，其次结果摘录是精确的，然后用户能在第一眼就看到他们想要的
结果，等等。文献 [31] 介绍了关于评价搜索系统的指标。评估指标需要具有具备一些条件：
   • 指标要能描述一种能表达完成搜索预期目标的特征，比如之前所提到的相关性特征。
   • 指标要能够定量描述完成搜索预期目标的效果。
   • 指标所采用的度量技术要精确而经济。
   • 指标要能够进行误差估计。
在此，我们介绍两种较为简单、常用的评价指标。
                                                         21
4.3.1 查准率及查全率
     查准率和查全率都是传统的有效性指标，它们都是基于两个基本假设的 [31] :
1) 对于一个用查询来表示的用户信息需求（information need），且在一个文档集合中，那么文档集中
    的每个文档与这种用户的信息需求要么相关，要么不相关。
2) 信息需求和文档就能完全确定文档的相关性，相关性与文档集中其他文档的搜索引擎排名无关。
     查全率和查准率被用来评价搜索系统在响应某个查询时检索出来的无序的文档集合，它们可能是信
息检索评价指标中最古老、最朴素的。
     查全率（recall）描述了搜索结果的文档集中相关文档所占的比例，根据这个定义，如果用Resu表
示被检索出来的文档集合，用Rela表示相关文档集，那么查全率就可以表述为：
                                                 |Resu ∩ Rela|
                                    recall =                                                    (7)
                                                       |Rela|
     容易发现，查全率在描述了相关度文档所占的比例，但它很容易就能实现1.0的查全率——只要将文
档集中所有文档作为结果返回即可。这样虽然保证了相关文档都在返回文档集合中，却不能保证返回的
文档集合里的文档都是相关文档。所以再引入查准率（precision）来评价，即搜索系统检索出的相关文
档占检索出的全部文档的比例，表述为：
                                                   |Resu ∩ Rela|
                                precision =                                                     (8)
                                                         |Res|
     从以上查全率、查准率的定义可以看出，它们确实能够一定程度上刻画搜索结果的优劣。但是它忽
略了排序对于一个搜索系统的重要作用，用户一般会采用从上到下，从前往后的顺序进行检查，检查每
一个文档都会付出一定的代价，所以能够排在前面的条目当然更应该是用户所想要的结果。在这种前提
下，用户按一定顺序进行检查，那么查全率、查准率都会随着检查过程发生变化。要准备地描述这种变
化，就要绘制P-R图（查准率-查全率图）。
     举个例子，对于一个确定文档集及信息查询实例，包含查询q的相关文献的集合R是确定了的，不失
一般性，假设R由下列文档组成:
                     R = {d2 , d5 , d23 , d31 , d57 , d89 , d97 , d111 , d137 , d229 )
     现在由一个搜索系统以查询q进行搜索，返回了搜索结果：
          √                 √                                      √
  1. d137             4. d5                              7. d57                        10. d55
         √                                                         √
  2. d23              5. d112                            8. d23                        11. d101
  3. d4               6. d92                             9. d67                        12. d34
     打勾的结果d是与查询q相关的文档，即di ∈ R。下面按照搜索的结果开始逐个检查，分别计算其查
全率和查准率，步骤如下：
a) 搜索结果中的第一篇文档d137 是相关的，得出查准率是100%，总共有十篇相关文档，现在找到一篇，
    查全率是10%；
b) 第二篇文档d23 是相关的，进行类似的计算，得到查准率是100%，查全率是20%；
c) 到了第四篇文档d5 ，查准率是75%，查全率是30%；
     重复这个操作，就可以达到一组查准率-查全率的点，从而得到P-R图。通过以上数据，绘制出相应
的P-R图，如图16。
     在上面的例子中，是针对一个查询请求的，但是在实际性能测试中，应该通过不同的查询来评价搜
索算法。不同的查询就会对应不同的P-R曲线。为了综合地评价搜索系统的性能，可以对用平均查准率
（average precision）对每个查全率对应的不同的查准率进行平滑处理：
                                                   ∑ Pi (rec)
                                                   Nq
                                     ¯
                                     P (rec) =                                                  (9)
                                                   i=1
                                                            Nq
     其中P (rec)是在查全率为r的情况下，查准率的平均值，Nq 是查询请求的总数，Pi (req)是第i个查询
在查全率为rec时的查准率。
                                                  22
                                                              率全查
                                     查全率
                            图 16: 范例P-R图
  在实际应用中，可能会遇到不同的查询对应的查全率是不一样的，这就需要对查全率进行插补操
作。查准率的插补是这样进行的： 设recj (j ∈ {0, 1, 2, . . .)为第j个标准查全率的参量，那么有
                   P (recj ) = maxrecj ≤rec≤recj +1 P (rec)         (10)
  具体使用方法将会在后面针对搜索系统的实验中阐述。
5 其他系统实施技术
  前面部分介绍了整个搜索系统的核心部分，但是对于一个完整的系统，在实施的过程中，还有很多
较为零碎的技术问题。比如用数据库来组织文档库的方法，建立服务器，编写用户前端等。在这一部
分，将就这些问题进行介绍。
5.1 数据库技术
    所谓数据库（Database）是按照一定的数据结构来组织、存储和管理数据的仓库。面对现代的信息
爆炸，数据管理已经不仅仅是简单的存储和管理数据，从最简单的填有各种数据的表格到企业内部具有
复杂关系的海量数据，如果我们的生活已经变得充满了数据，那么数据库作为这些数据的载体，自然也
是无所不在的了。
    一个字面上相似的概念是数据库系统（Database Systems），数据库系统是用于对数据进行组织和
存取操作的管理系统，它是一个更广义的概念，包含了数据库及其管理软件，是存储介质、处理对象和
管理系统的集合体。其中有一个重要的组织部分——数据库管理系统（Database Management System，
DBMS），它用于对数据库中的数据进行管理、组织和维护，它覆盖了从较低层的内外存储空间的分配，
到较高层的语法定义和读写创删的方法。是与数据库的数据打交道的重要手段。
5.1.1 文档库建立
  利用爬虫程序，我们从维基百科上获得了5000余篇机械领域相关词条的文章，以此来模拟文档库，
随着运用的深入，这些文章的内容和数量都会得到很大的扩展，但是解决问题的方式是极相似的。该搜
索系统本来就要求具有较强的扩展性和可移植性。在系统体系结构中，功能集部分了包含了数据库建立
与维护部分。下面将要介绍如何利用Java自带的数据库操作的相关包，来完成文档库建立的工作。
  前面介绍了，本系统采用MySQL数据库。首先，分析爬虫程序获得的模拟语料库，确定数据库结构，
系统存储的信息并没有复杂的联系，用一张数据表就可以完成，它包含了以下几个字段：
  • id：文件ID，用来对文本进行编号，这也是索引、数据库、网页前端交流数据库信息的主要参数，
    id是数据库的主键，同时也是一个自增字段。
                                     23
   • filename:文件名，用来保存文本的名称。
   • contents:内容，用来保存文本的具体内容。
   • fullpath:完整路径，保存文本所在的绝对路径。在搜索结果中，这个字段是不必要的。在前文用
     Lucene建立索引的阶段，也并没有建立对应的fullpath域。此处的考虑是，索引域并不是与数据库
     的字段有完全的对应关系。这个字段的加入，表明在数据库中，我们可以再存储大量的没有被建立
     索引的数据，索引为搜索服务，搜索获得的文件ID号，将会引导到数据库中获得信息。所以索引应
     该只是一把钥匙，数据库才是数据的仓库。
    建立数据表有两种方式，一种是直接用SQL语言进行操作，另一种是利用MySQL自带的工作台Work-
Bench进行可视化的操作。采用通用性更强的第一种方法建立了数据库、数据表、字段及字段类型，再用
WorkBench进行必要的修改，获得数据库如图17。
                                图 17: 数据库结构
    现在完成了数据库结构的设计，下一步就要用具体的内容来填充它。此处数据库的操作较为简单，
就采用了Java自带的JDBC进行文档数据库的添加新数据的操作。大致流程如图18。
                           图 18: 数据库信息写入流程
    JDBC为访问数据库提供了极为方便的接口。
import java . sql .*;
Connection con = DriverManager . getConnection ( url , usr , pwd );
    通过引用java.sql包下的相关类，实例化出一个Connection类的对象，以数据库的URL、用户名、密
码为参数，调用DriverManager类的静态方法getConnection，就可以实现与数据库的连接。接下来要向
                                       24
数据库中添加信息。用JDBC来操作数据库的核心之一，就是在Java中执行SQL语言，在这儿有必要对SQL
语言进行一定的介绍。
      SQL（结构化查询语言，Structured Query Language），是用来对数据库进行读写添删等操作的计
算机语言，用户不用考虑数据的具体存储方式，只需在高层数据结构上进行操作。SQL的操纵对象是记录
项目（records）的集合，所以SQL接受记录项目集为输入，又输出记录项目集，这样一来，SQL语句能够
嵌套，从而使他具有极大的灵活性。SQL的一个语句就可以描述相当复杂的查询要求，而要用其他编程语
言实现相同的功能，可能需要一段不短的代码。
      SQL语句大致被分为两个部分：数据操作语言（DML，Data Manipulation Language）和数据定义语
言（DDL，Data Definition Language）。由于篇幅的限制，此处就只介绍本系统中使用到的语言。
      数据定义语言是用于实现数据库结构上的操作，比如新建、删除数据表，定义键、字段，规定表格
之间的联系等。本系统建立过程中用到的数据定义语言指令有：
     • create database:用于新建数据库
     • create table:用于新建数据表
      前面提到了采用SQL语言建立本系统所需要的数据表，大致代码如下：
c r e a t e database mechanicaldesigndb ; −−创建数据库
use mechanicaldesigndb ; −−以该数据库为操作对象
c r e a t e t a b l e stuff ; −−创建数据表
(
              id i n t AUTO_INCREMENT , −−新建整型的字段，它具有自增的属性id
              filename var char (128) , −−新建长度为字节的字符串型128字段filename
              /*用类似的方法新建，
              fullpath 字段content
              */
              primary key ( id ) −−定义字段为主键id
)
      这样就完成了数据库及数据表结构上的搭建，这种建立方法是基本不依赖于数据库软件的，也就是
说尽管现在系统采用的是MySQL数据库，但是这种方法可以很容易地移植到其他数据库上。下面介绍在数
据表内容上的操作方法。
      SQL是用于查询数据库的语言，它同时也肩负着插入、删除、更新记录的任务。这些就是由数据操作
语言部分来完成，常用的操作指令有：
     • SELECT:用于从数据表中获得数据。
     • INSERT:用于向数据表中添加数据。
      在将文档集写进数据库的操作中，id字段并不是文档集中的文档自带的，在数据库中，我们建立了
自增的id号，数据库中它可以自行获得，但是如前文所述，这个id将会要作为一个关键参数沟通数据
库、索引和网页前端，这就要求从数据库中获得id号，然后把它编入索引当中。这恰就是一个最简单的
查询范例。
s e l e c t max( id )+1 from stuff
      简单地解释一下，select语句的语法结构为：SELECT 列名称 FROM 表名称。（SQL语言对大小写不
敏感，也就是select和SELECT是完全等效的）。通过这个语句可以获得某个表中的某一列或者几列的数
据。列名称所在的位置很灵活的，可以使用通配符“*”来获得所有的列数据，也可以像上面代码这样，
在列名称的位置写SQL的内建函数。max()就是SQL的内建函数，用来获得某一列的最大值。通过这个语句
就可以获得当前数据库数据条目的数目，再加1，作为下一个条目的id，编进索引的id域中。
      完成id字段的操作，下面就需要把文档中的内容导入到数据库中，SQL提供了增加记录项目的语句
insert，其语法结构为：INSERT INTO 表名称 VALUES (值1, 值2,....) 或 INSERT INTO table_name
(列1, 列2,...) VALUES (值1, 值2,....),可以实现相应的功能。
      前面提到，有了JDBC，就可以在Java中执行SQL语句。以上面获得最大id的语句，在java中需要是这
样实现的：
Statement pstmt = n u l l ; //定义一个类的对象Statement
pstmt = con . prepareStatement (" alter ␣ table ␣ stuff ␣ AUTO_INCREMENT ␣ 1; " );
//把语句作为一个参数传给类对象的SQLConnectionprepareStatement方法()
pstmt . execute (); //执行这个类的对象Statement
                                            25
      Statement类是用来执行静态的SQL语句，并返回SQL语句产生的结果。通常情况下，一个Statement
类的对象只能获得一个结果集，也就是说，对于不同的结果集，必须要建立不同的Statement类对象。
      由于在进行SQL查询时，可能会需要输入不同的参量，Statement类提供了setString方法，以给定的
Java字符串来设置SQL语句的参数，驱动器会把Java字符串转换成规模对应的SQL串。举个例子：
// ...
String expr = " insert ␣ into ␣ stuff ␣( filename ,␣ fullpath ,␣ contents )␣ values ␣ (? ,? ,?) ";
pstmt = con . prepareStatement ( expr );
pstmt . setString (1 , filename );
// ...
      这样就可以以之前定的字符串filename作为第一个参数，代替掉第一行最后括号中的第一个问号。
通过这样的方法，可以分别获取文件名、文件内容、完整路径信息，并把它们写进数据库。这样就实现
了建立文档数据库的功能。
      至此，系统体系结构中的资源层已经架设完毕。
5.1.2 数据库读取操作
      上面介绍了用JDBC来实现数据库建立的方法，而对于数据库的操作，还有一个鼎鼎大名的包—
—Hibernate，也就是最常用的Java Web应用开发架构组合SSH中的那个H（另外两个分别为Spring和
Struts 2）。Hibernate是基于JDBC的，它封装了访问数据库的底层细节，因此JDBC具有较强的灵活性，
而Hibernate具用较强的易用性和易学性。考虑到搭建这个系统的另一个目的是要熟悉Web应用开发的流
程及各种组件，所以在数据库读取操作中，系统采用了Hibernate而非JDBC。
      目前流行的编程语言，Java、C++等都是面向对象的，但是主流的数据库产品又还是关系数据
库 [32] 。这两者发展由于理念上的差异，造成发展不协调，也就催生了ORM（Object/Relation Mapping）
框架来沟通连接这两者，通过ORM框架，应用程序就不用直接访问底层数据库。Hibernate就是ORM框架中
较为常用的一种。Hibernate是由JBOSS提供的一套开源的对象关系映射框架，通过对JDBC进行封装，其
最大的特点就是把数据库当作一个对象，因此可以用面向对象的思维来操纵数据库，这些对数据库的操
作将会被ORM解析成SQL操作，从而避开了一些有时冗长艰涩的SQL语言，数据结果也从数据表的表现形式
变成了对象的形式，这对于那些采用面向对象的业务模性和商业逻辑的应用是有利的。
      对于ORM框架，有一个非常重要的媒介——PO（持久化对象，Persistent Object）。正是通过PO才
能完成持久化操作，也就是前面所说的以面向对象的方式来操纵数据库。在Hibernate中PO是很简单的：
                                     P O＝P OJO＋映射文件
      其中POJO是指普通Java类，由于Hibernate的低浸入式设计，POJO类与普通JavaBeans是一样的，它
不要求持久化类继承什么父类或是实现什么接口。Hibernate中的映射文件以XML的形式书写，通过映射
文件，Hibernate就可以理解持久化类和数据表之间的关系，也可以理解持久化类属性与数据表列之间的
关系。以本搜索系统的使用为例：
< hibernate−mapping package =" myPackage " >
  < class name =" SearchResult " table = " stuff " >
    <id name =" id " >
      < generator class =" identity "/ >
    </ id >
    < property name =" contents "/ >
    < property name =" filename "/ >
    < property name =" fullpath "/ >
  </ class >
</ hibernate−mapping >
      上面的映射文件中定义的property的name与POJO类中一一对应。这样一样就实现了持久化对象。接
下来通过Hibernate配置文件hibernate.cfg.xml，配置出数据库的类型、URL、用户名、密码，以及映射
文件的路径，就完成了Hibernate的前期配置工作。可以开始利用Hibernate来操作数据库了。
      回顾一下搜索系统工作流程，系统接受用户的查询请求，通过语义扩展生成了新的请求，以它在索
引中搜索，获得了结果文本的ID号，然后通过这个ID号获得搜索结果的具体内容。那么用Hibernate要实
现的功能就是要通过ID号在数据库中找到该ID号对应项的其他字段的信息。根据Hibernate的框架规范，
建立一个包含id、 contents、 filename、 fullpath的POJO类SearchResult，其形式是JavaBean。按照
上面的映射文件，进行映射配置。接下来建立通过ID查内容的方法：
                                             26
p u b l i c s t a t i c SearchResult findStuffById ( String id ){
  Session sess = HibernateUtil . currentSession ();
  //开始事务
  Transaction tx = sess . beginTransaction ();
  //创建消息实例
  List pl = sess .
              createQuery (" select ␣ stuff ␣ from ␣ SearchResult ␣ as ␣ stuff ␣ where ␣ id ␣=␣: id " )
              . setString (" id " , id ). list ();
  //通过号获得数据库中该号对应的记录idid
  Iterator pit = pl . iterator ();
  //用迭代器来获得类里的信息List
  SearchResult s = ( SearchResult ) pit . next ();
  //以类保存查询结果，SearchResult
  tx . commit ();
  //提交事务
  HibernateUtil . closeSession ();
  //关闭事务
  r e t u r n s;
}
      这样一来，用id号获得的数据库中的记录就变成了一个SearchResult类的对象，这样一来“find-
StuffByID("1").getfilename”就可以获得id号为1的记录中文件名信息。这对于之后网页前端的显示来
说是极为方便的。
      到这里，系统体系结构中的应用服务层也搭建完毕，通过Jena、Hibernate、JDBC等包，实现了与资
源层的信息交互，完成了扩展性语义搜索、索引器、数据库维护器等功能集的设计与制作，后台已经准
备好，下面就要考虑设计前端，使用户可以通过它，与后台打交道，获得相对应的服务。
5.2 服务器技术
      在系统设计之初，我们就把它定位成能够跨平台的搜索系统，一个Web应用程序恰能较简单地实现这
样的功能。什么是Web应用程序呢？
      所谓Web应用程序是一种可以通过Web访问的应用程序，其优势在于用户不需要安装其他软件，只需
在浏览器中即可访问应用程序。
      传统的应用程序是被完全部署在一台计算机上的，就像早期的单机游戏，只要通过光盘安装在了本
地的计算机，你不需要与其他电脑产生任何联系，就可以完美地运行。但是随着互联网的迅速发展，人
们已经不在满足于局限在一台计算机上的资源，而希望使用其他计算机的信息和资源，这就催生了Web应
用程序。
      与传统的应用程序不同，Web应用程序可能并不是被部署在一台计算机上，或者说应用程序所在的
计算机可能与调用该应用程序的计算机不同。这种应用程序至少与两台计算机发生了关系，所以就产生
了两种不同的架构：B/S架构，即浏览器（Browser）／服务器（Server）架构，与此相对应的还有C/S架
构，即客户端（Client）/服务器（Server）架构。两种架构都涉及了S端，即服务器端，从字面上说，
它是提供服务的机器，因为它可能需要同时给多个浏览器（或客户端）提供服务，所以要求服务器端计
算机拥有较好的性能。下面再来看看两种架构的不同点，对于B/S架构，它是从浏览器中获得服务器的服
务的，这样一来，只要有一个浏览器，你就可以享受到不同服务器提供的不同服务；对于C/S架构，需要
在C端，即客户端部署程序，这个程序可以自己完成一些任务，也可以与服务器进行信息的交互。这样我
们看出，对于B／S架构，在浏览器中几乎是只发出服务请求，而很少承担完成服务所需要的工作，比如
对于一个聊天室，浏览器端完成的只是发送信息到服务器，再从服务器上获取信息这样的简单的工作；
相对应的，对于C/S架构，客户端就会承担完成服务的较多工作（相比较B/S架构而言），这一方面是受
到服务器端计算机性能的限制，另一方面也是受到网络传输的限制，所以在客户端就需要部署相应的较
为复杂的程序，而这个程序不能简单地放在浏览器中来完成，比如对于一个大型网游，画面的渲染就是
一个计算量颇大的任务，如果把这些工作都交给服务器来完成，可能服务器吃不消，可能网络传输速度
的限制就让你根本无法足够迅速的传送渲染的请求并接收服务器端的渲染结果。所以这种架构其实是在
平衡远程计算机和本地计算机的负载。
      针对我们的搜索系统，用户所需要的信息只是搜索体系的资源层中的小小一部分，所以把整个资源
层放在本地计算机上是相当不划算的，但是整个搜索系统又都依托于资源层。这样一来，要完成一个搜
索任务，本地计算机能完成的工作是极其有限的，几乎所有的业务逻辑都要在服务器端来实现。所以我
们采用了B/S架构，这样一来通过浏览器就可以访问搜索系统，而不用在本地安装其他软件，很容易就实
现了应用的跨平台性。
                                                   27
     上面多次提到服务器，那么什么才是服务器呢？根据全国科学技术名词审定委员会定义，服务器是
指一种运行管理软件以控制对网络或网络资源（磁盘驱动器、打印机等）进行访问的计算机，并能够为
在网络上的计算机提供资源使其犹如工作站那样地进行操作。那么归根结底，服务器也是一种计算机，
只是性能上会优于普通的个人计算机，那么它是依靠什么机制来让它成为可以提供服务的服务器而不是
一般计算机的呢？是Web服务器。需要与之前说的服务器相区分。之前说的服务器是硬件，是一台性能优
越的计算机；而Web服务器是程序，是可以接收浏览器发出的请求，并做出回应，给出结果的程序。
     由此可见，通过Web服务器，普通的个人电脑也可以充当服务器。之前我们提到了搜索系统采用B/S
架构，那么这种架构会涉及到两端：服务器端和浏览器端。而正是Web服务器，将该计算机的一部分作为
服务器，再用同一台计算机（当然对于其他计算机也是相同的）的浏览器访问这个服务器，获得相关服
务，这样一来就 让一台电脑分饰两角了。
5.2.1 Tomcat
5.3 前端
5.3.1 ExtJS
5.3.2 用户界面编写
6 系统实现
6.1 需求分析
6.1.1 任务概述
6.1.2 功能需求
6.1.3 数据描述
6.1.4 运行需求
6.1.5 其他需求
6.2 概要设计
6.2.1 基本处理流程
6.2.2 组织结构
6.2.3 模块划分
6.2.4 接口设计
6.2.5 数据结构设计
6.3 详细设计
6.4 测试
6.4.1 查准率实验
6.4.2 查全率实验
6.5 系统展示
                           28
参考文献
 [1] J.R. Marsh. The capture and utilization of experience in engineering design.
 [2] 舒慧林, 刘继红, and 钟毅芳. 计算机辅助机械产品概念设计研究综述. 计算机辅助设计与图形学
     学报, 12(12):947--954, 2000.
 [3] Fabian M Suchanek, Gjergji Kasneci, and Gerhard Weikum. Yago: A large ontology from
     wikipedia and wordnet. Web Semantics: Science, Services and Agents on the World Wide
     Web, 6(3):203--217, 2008.
 [4] Michael Ashburner, Catherine A Ball, Judith A Blake, David Botstein, Heather Butler,
     J Michael Cherry, Allan P Davis, Kara Dolinski, Selina S Dwight, Janan T Eppig, et al.
     Gene ontology: tool for the unification of biology. Nature genetics, 25(1):25--29,
     2000.
 [5] Alexander Maedche and Steffen Staab. Ontology learning for the semantic web. Intelligent
     Systems, IEEE, 16(2):72--79, 2001.
 [6] Deborah L McGuinness, Frank Van Harmelen, et al. Owl web ontology language overview.
     W3C recommendation, 10(2004-03):10, 2004.
 [7] 王英林, 王卫东, 王宗江, 佟平, 许萌, 张申生, and 张亚莉. 基于本体的可重构知识管理平台.
     计算机集成制造系统, 9(12), 2003.
 [8] 金芝 et al. 基于本体的需求自动获取. 计算机学报, 23(5):486--492, 2000.
 [9] 李景 and 孟连生. 构建知识本体方法体系的比较研究. 现代图书情报技术, 7:17--22, 2004.
[10] Ramanathan Guha, Rob McCool, and Eric Miller. Semantic search. In Proceedings of the
     12th international conference on World Wide Web, pages 700--709. ACM, 2003.
[11] Thanh Tran, Philipp Cimiano, Sebastian Rudolph, and Rudi Studer. Ontology-based in-
     terpretation of keywords for semantic search. In The Semantic Web, pages 523--536.
     Springer, 2007.
[12] Qi Zhou, Chong Wang, Miao Xiong, Haofen Wang, and Yong Yu. Spark: adapting keyword
     query to semantic search. In The Semantic Web, pages 694--707. Springer, 2007.
[13] Li Ding, Tim Finin, Anupam Joshi, Rong Pan, R Scott Cost, Yun Peng, Pavan Reddivari,
     Vishal Doshi, and Joel Sachs. Swoogle: a search and metadata engine for the semantic
     web. In Proceedings of the thirteenth ACM international conference on Information and
     knowledge management, pages 652--659. ACM, 2004.
[14] David Vallet, Miriam Fernández, and Pablo Castells. An ontology-based information
     retrieval model. In The Semantic Web: Research and Applications, pages 455--470.
     Springer, 2005.
[15] Sugato Chakrabarty, Rahul Chougule, and Ronald M Lesperance. Ontology-guided knowledge
     retrieval in an automobile assembly environment. The International Journal of Advanced
     Manufacturing Technology, 44(11-12):1237--1249, 2009.
[16] Zhanjun Li, Victor Raskin, and Karthik Ramani. Developing ontologies for engineering
     information retrieval. In Proceedings of the ASME, pages 4--7, 2007.
[17] Hsien-Tang Lin, Nai-Wen Chi, and Shang-Hsien Hsieh. A concept-based information retrieval
     approach for engineering domain-specific technical documents. Advanced Engineering
     Informatics, 26(2):349--360, 2012.
[18] Anjian Ren, Xiaoyong Du, and Puwei Wang. Ontology-based categorization of web search
     results using yago. In Computational Sciences and Optimization, 2009. CSO 2009. Inter-
     national Joint Conference on, volume 1, pages 800--804. IEEE, 2009.
[19] Dong Yang, Ming Dong, and Rui Miao. Development of a product configuration system with
     an ontology-based approach. Computer-Aided Design, 40(8):863--878, 2008.
                                              29
[20] 郭剑锋, 顾新建, 祁国宁, 王生发, and 马军. 零件库中基于本体的智能搜索引擎的研究与实现.
     浙江大学学报: 工学版, 41(4):639--645, 2007.
[21] Christopher D Manning, Prabhakar Raghavan, and Hinrich Schutze. 信息检索导论, 2010.
[22] A.Grossman David and Frieder Ophir. 信息检索：算法与启发式方法, 2010.
[23] 李成刚. 基于内容的三维模型搜索引擎技术研究与系统开发. PhD thesis, 北京: 清华大学,
     2011.
[24] Gerald Salton. Automatic text processing. Science, 168(3929):335--343, 1970.
[25] Gerard Salton, Anita Wong, and Chung-Shu Yang. A vector space model for automatic
     indexing. Communications of the ACM, 18(11):613--620, 1975.
[26] Stephen E Robertson and K Sparck Jones. Relevance weighting of search terms. Journal
     of the American Society for Information science, 27(3):129--146, 1976.
[27] Jay M Ponte and W Bruce Croft. A language modeling approach to information retrieval.
     In Proceedings of the 21st annual international ACM SIGIR conference on Research and
     development in information retrieval, pages 275--281. ACM, 1998.
[28] 陈文伟 and 陈晟. 知识工程与知识管理. 计算机科学与技术学科前沿丛书. 清华大学出版社,
     2010.
[29] Tom Gruber. What is an ontology? Knowledge Acquisition, 5(2):199--220, 1993.
[30] Graham Klyne, Jeremy J Carroll, and Brian McBride. Resource description framework (rdf):
     Concepts and abstract syntax. W3C recommendation, 10, 2004.
[31] Stefan Büttcher, Charles Clarke, and Gordon V Cormack. Information retrieval: Imple-
     menting and evaluating search engines. The MIT Press, 2010.
[32] 李刚. 轻量级 Java EE 企业应用实战: Struts 2+ Spring+ Hibernate 整合开发. 电子工业出版
     社, 2008.
                                              30
